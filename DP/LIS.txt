Given an array of integers, find the length of the longest (strictly) increasing subsequence from the given array.


//This approach uses binary search it calculates a temp vector and adds and replaces in it and then outputs its length which gives LIS.
// TC:O(nlogn) SC:O(n)
int longestSubsequence(int n, int a[])
    {
        vector<int> x;
        x.push_back(a[0]);
        for(int i=1;i<n;i++)
        {
            int p=lower_bound(x.begin(),x.end(),a[i])-x.begin();
            if(p>x.size()-1)
            x.push_back(a[i]);
            else
            x[p]=a[i];
        }
        return x.size();
    }
    
    
// This is another approach it has SC:O(n) and TC:O(n^2)
In this approach we initialize the value of LIS at every position as 1 then use the values of previous elements to modify the Lis value at that index depending if the previously element is smaller than the desired or current element.

int longestSubsequence(int n, int a[])
    {
        int dp[n];
        int ans=0;
        for(int i=0;i<n;i++)dp[i]=1;
        // memset(dp,1,sizeof(dp));
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<i;j++)
            {
                if(a[i]>a[j])
                dp[i]=max(dp[i],dp[j]+1);
            }
            ans=max(ans,dp[i]);
        }
        return ans;
       // your code here
    }    
